diff --git a/ranger/core/fm.py b/ranger/core/fm.py
index 61b3cb11..ce93ca9c 100644
--- a/ranger/core/fm.py
+++ b/ranger/core/fm.py
@@ -26,7 +26,9 @@ from ranger.ext.img_display import (W3MImageDisplayer, ITerm2ImageDisplayer,
                                     TerminologyImageDisplayer,
                                     URXVTImageDisplayer, URXVTImageFSDisplayer,
                                     KittyImageDisplayer,
-                                    ImageDisplayer)
+                                    ImageDisplayer,
+                                    MPVImageDisplayer
+                                    )
 from ranger.core.metadata import MetadataManager
 from ranger.ext.rifle import Rifle
 from ranger.container.directory import Directory
@@ -238,6 +240,8 @@ class FM(Actions,  # pylint: disable=too-many-instance-attributes
             return URXVTImageFSDisplayer()
         elif self.settings.preview_images_method == "kitty":
             return KittyImageDisplayer()
+        elif self.settings.preview_images_method == "mpv":
+            return MPVImageDisplayer()
         return ImageDisplayer()
 
     def _get_thisfile(self):
diff --git a/ranger/ext/img_display.py b/ranger/ext/img_display.py
index 3f5b5471..0176d965 100644
--- a/ranger/ext/img_display.py
+++ b/ranger/ext/img_display.py
@@ -667,3 +667,70 @@ class KittyImageDisplayer(ImageDisplayer):
         #         os.remove(self.temp_paths[k])
         #     except (OSError, IOError):
         #         continue
+
+import subprocess
+import json
+import atexit
+import socket
+from pathlib import Path
+
+import logging
+from logging import info
+import traceback
+
+class MPVImageDisplayer(ImageDisplayer):
+    """Implementation of ImageDisplayer using mpv, a general media viewer.
+    Opens media in a separate X window.
+
+    mpv 0.25+ needs to be installed for this to work.
+    """
+
+    def _send_command(self, path, sock):
+        message = '{"command": ["raw","loadfile",%s]}\n' % json.dumps(path)
+        s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
+        s.connect(str(sock))
+        info('-> ' + message)
+        s.send(message.encode())
+        message = s.recv(1024).decode()
+        info('<- ' + message)
+
+    def _launch_mpv(self, path, sock):
+
+        proc = Popen([
+            * os.environ.get("MPV", "mpv").split(),
+            "--no-terminal",
+            "--title=mpv-preview",
+            "--force-window",
+            "--input-ipc-server=" + str(sock),
+            "--image-display-duration=inf",
+            "--loop-file=inf",
+            "--no-osc",
+            "--no-input-default-bindings",
+            "--keep-open",
+            "--idle",
+            "--",
+            path,
+        ])
+
+        @atexit.register
+        def cleanup():
+            proc.terminate()
+            sock.unlink()
+
+    def draw(self, path, start_x, start_y, width, height):
+
+        path = os.path.abspath(path)
+        cache = Path(os.environ.get("XDG_CACHE_HOME", "~/.cache")).expanduser()
+        cache = cache / "ranger"
+        cache.mkdir(exist_ok=True)
+        sock = cache / "image-slave.sock"
+
+        try:
+            self._send_command(path, sock)
+        except (ConnectionRefusedError, FileNotFoundError):
+            info('LAUNCHING ' + path)
+            self._launch_mpv(path, sock)
+        except Exception as e:
+            logging.exception(traceback.format_exc())
+            sys.exit(1)
+        info('SUCCESS')
diff --git a/ranger/ext/vcs/vcs.py b/ranger/ext/vcs/vcs.py
index e2838f8d..a12fb380 100644
--- a/ranger/ext/vcs/vcs.py
+++ b/ranger/ext/vcs/vcs.py
@@ -256,9 +256,11 @@ class VcsRoot(Vcs):  # pylint: disable=abstract-method
         self.updatetime = time.time()
         return True
 
-    def _update_walk(self, path, purge):  # pylint: disable=too-many-branches
+    def _update_walk(self, path, purge, isInterrupt=None):  # pylint: disable=too-many-branches
         """Update walk"""
         for wroot, wdirs, _ in os.walk(path):
+            if(isInterrupt and isInterrupt()):
+                return
             # Only update loaded directories
             try:
                 wrootobj = self.obj.fm.directories[wroot]
@@ -272,6 +274,8 @@ class VcsRoot(Vcs):  # pylint: disable=abstract-method
             if wrootobj.content_loaded:
                 has_vcschild = False
                 for fsobj in wrootobj.files_all:
+                    if(isInterrupt and isInterrupt()):
+                        return
                     if purge:
                         if fsobj.is_directory:
                             fsobj.vcsstatus = None
@@ -290,14 +294,19 @@ class VcsRoot(Vcs):  # pylint: disable=abstract-method
                             fsobj.vcsstatus = self.status_subpath(
                                 os.path.join(wrootobj.realpath, fsobj.basename),
                                 is_directory=True,
+                                isInterrupt=isInterrupt
                             )
                     else:
                         fsobj.vcsstatus = self.status_subpath(
-                            os.path.join(wrootobj.realpath, fsobj.basename))
+                            os.path.join(wrootobj.realpath, fsobj.basename),
+                            isInterrupt=isInterrupt
+                            )
                 wrootobj.has_vcschild = has_vcschild
 
             # Remove dead directories
             for wdir in list(wdirs):
+                if(isInterrupt and isInterrupt()):
+                    return
                 try:
                     wdirobj = self.obj.fm.directories[os.path.join(wroot, wdir)]
                 except KeyError:
@@ -306,11 +315,13 @@ class VcsRoot(Vcs):  # pylint: disable=abstract-method
                 if not wdirobj.vcs.track or wdirobj.vcs.is_root_pointer:
                     wdirs.remove(wdir)
 
-    def update_tree(self, purge=False):
+    def update_tree(self, purge=False, isInterrupt=None):
         """Update tree state"""
-        self._update_walk(self.path, purge)
+        self._update_walk(self.path, purge, isInterrupt=isInterrupt)
         for path in list(self.links):
-            self._update_walk(path, purge)
+            if(isInterrupt and isInterrupt()):
+                return
+            self._update_walk(path, purge, isInterrupt=isInterrupt)
             try:
                 dirobj = self.obj.fm.directories[path]
             except KeyError:
@@ -325,12 +336,14 @@ class VcsRoot(Vcs):  # pylint: disable=abstract-method
         if purge:
             self.__init__(self.obj)
 
-    def check_outdated(self):
+    def check_outdated(self, isInterrupt=None):
         """Check if root is outdated"""
         if self.updatetime is None:
             return True
 
         for wroot, wdirs, _ in os.walk(self.path):
+            if(isInterrupt and isInterrupt()):
+                return False
             wrootobj = self.obj.fm.get_directory(wroot)
             wrootobj.load_if_outdated()
             if wroot != self.path and wrootobj.vcs.is_root_pointer:
@@ -345,7 +358,7 @@ class VcsRoot(Vcs):  # pylint: disable=abstract-method
                         return True
         return False
 
-    def status_subpath(self, path, is_directory=False):
+    def status_subpath(self, path, is_directory=False, isInterrupt=None):
         """
         Returns the status of path
 
@@ -359,6 +372,8 @@ class VcsRoot(Vcs):  # pylint: disable=abstract-method
         # check if relpath or its parents has a status
         tmppath = relpath
         while tmppath:
+            if(isInterrupt and isInterrupt()):
+                return 'none'
             if tmppath in self.status_subpaths:
                 return self.status_subpaths[tmppath]
             tmppath = os.path.dirname(tmppath)
@@ -403,6 +418,8 @@ class VcsThread(threading.Thread):  # pylint: disable=too-many-instance-attribut
 
         has_vcschild = False
         for fsobj in fsobjs:
+            if(self.isInterrupt()):
+                return
             if not fsobj.is_directory or not fsobj.vcs or not fsobj.vcs.track:
                 continue
 
@@ -412,7 +429,7 @@ class VcsThread(threading.Thread):  # pylint: disable=too-many-instance-attribut
                 if not rootvcs.rootinit and not self._is_targeted(rootvcs.obj):
                     self._roots.add(rootvcs.path)
                     if not rootvcs.init_root():
-                        rootvcs.update_tree(purge=True)
+                        rootvcs.update_tree(purge=True, isInterrupt=self.isInterrupt)
                     self._redraw = True
                 if fsobj.is_link:
                     fsobj.vcsstatus = rootvcs.obj.vcsstatus
@@ -428,12 +445,16 @@ class VcsThread(threading.Thread):  # pylint: disable=too-many-instance-attribut
         self._roots.clear()
 
         while True:
+            if(self.isInterrupt()):
+                return
             try:
                 dirobjs.append(self._queue.get(block=False))
             except queue.Empty:
                 break
 
         for dirobj in dirobjs:
+            if(self.isInterrupt()):
+                return
             if dirobj.path in paths:
                 continue
             paths.add(dirobj.path)
@@ -441,14 +462,17 @@ class VcsThread(threading.Thread):  # pylint: disable=too-many-instance-attribut
             dirobj.vcs.reinit()
             if dirobj.vcs.track:
                 rootvcs = dirobj.vcs.rootvcs
-                if rootvcs.path not in self._roots and rootvcs.check_outdated():
+                if rootvcs.path not in self._roots and rootvcs.check_outdated(isInterrupt=self.isInterrupt):
                     self._roots.add(rootvcs.path)
                     if rootvcs.update_root():
-                        rootvcs.update_tree()
+                        rootvcs.update_tree(isInterrupt=self.isInterrupt)
                     else:
-                        rootvcs.update_tree(purge=True)
+                        rootvcs.update_tree(purge=True, isInterrupt=self.isInterrupt)
                     self._redraw = True
 
+            if(self.isInterrupt()):
+                return
+
             has_vcschild = self._update_subroots(dirobj.files_all)
 
             if dirobj.has_vcschild != has_vcschild:
@@ -471,15 +495,21 @@ class VcsThread(threading.Thread):  # pylint: disable=too-many-instance-attribut
             try:
                 self._queue_process()
 
+                if(self.isInterrupt()):
+                    continue
                 if self._redraw:
                     self._redraw = False
                     for column in self._ui.browser.columns:
+                        if(self.isInterrupt()):
+                            break
                         if column.target and column.target.is_directory:
                             column.need_redraw = True
                     self._ui.status.need_redraw = True
                     self._ui.redraw()
             except Exception as ex:  # pylint: disable=broad-except
                 self._ui.fm.notify('VCS Exception: View log for more info', bad=True, exception=ex)
+    def isInterrupt(self):
+        return self.__stop.isSet() or (not self._advance.isSet())
 
     def stop(self):
         """Stop thread synchronously"""
