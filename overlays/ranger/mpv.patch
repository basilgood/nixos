diff --git a/ranger/core/fm.py b/ranger/core/fm.py
index 61b3cb11..ce93ca9c 100644
--- a/ranger/core/fm.py
+++ b/ranger/core/fm.py
@@ -26,7 +26,9 @@ from ranger.ext.img_display import (W3MImageDisplayer, ITerm2ImageDisplayer,
                                     TerminologyImageDisplayer,
                                     URXVTImageDisplayer, URXVTImageFSDisplayer,
                                     KittyImageDisplayer,
-                                    ImageDisplayer)
+                                    ImageDisplayer,
+                                    MPVImageDisplayer
+                                    )
 from ranger.core.metadata import MetadataManager
 from ranger.ext.rifle import Rifle
 from ranger.container.directory import Directory
@@ -238,6 +240,8 @@ class FM(Actions,  # pylint: disable=too-many-instance-attributes
             return URXVTImageFSDisplayer()
         elif self.settings.preview_images_method == "kitty":
             return KittyImageDisplayer()
+        elif self.settings.preview_images_method == "mpv":
+            return MPVImageDisplayer()
         return ImageDisplayer()
 
     def _get_thisfile(self):
diff --git a/ranger/ext/img_display.py b/ranger/ext/img_display.py
index 3f5b5471..0176d965 100644
--- a/ranger/ext/img_display.py
+++ b/ranger/ext/img_display.py
@@ -667,3 +667,70 @@ class KittyImageDisplayer(ImageDisplayer):
         #         os.remove(self.temp_paths[k])
         #     except (OSError, IOError):
         #         continue
+
+import subprocess
+import json
+import atexit
+import socket
+from pathlib import Path
+
+import logging
+from logging import info
+import traceback
+
+class MPVImageDisplayer(ImageDisplayer):
+    """Implementation of ImageDisplayer using mpv, a general media viewer.
+    Opens media in a separate X window.
+
+    mpv 0.25+ needs to be installed for this to work.
+    """
+
+    def _send_command(self, path, sock):
+        message = '{"command": ["raw","loadfile",%s]}\n' % json.dumps(path)
+        s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
+        s.connect(str(sock))
+        info('-> ' + message)
+        s.send(message.encode())
+        message = s.recv(1024).decode()
+        info('<- ' + message)
+
+    def _launch_mpv(self, path, sock):
+
+        proc = Popen([
+            * os.environ.get("MPV", "mpv").split(),
+            "--no-terminal",
+            "--title=mpv-preview",
+            "--force-window",
+            "--input-ipc-server=" + str(sock),
+            "--image-display-duration=inf",
+            "--loop-file=inf",
+            "--no-osc",
+            "--no-input-default-bindings",
+            "--keep-open",
+            "--idle",
+            "--",
+            path,
+        ])
+
+        @atexit.register
+        def cleanup():
+            proc.terminate()
+            sock.unlink()
+
+    def draw(self, path, start_x, start_y, width, height):
+
+        path = os.path.abspath(path)
+        cache = Path(os.environ.get("XDG_CACHE_HOME", "~/.cache")).expanduser()
+        cache = cache / "ranger"
+        cache.mkdir(exist_ok=True)
+        sock = cache / "image-slave.sock"
+
+        try:
+            self._send_command(path, sock)
+        except (ConnectionRefusedError, FileNotFoundError):
+            info('LAUNCHING ' + path)
+            self._launch_mpv(path, sock)
+        except Exception as e:
+            logging.exception(traceback.format_exc())
+            sys.exit(1)
+        info('SUCCESS')
diff --git a/ranger/ext/vcs/vcs.py b/ranger/ext/vcs/vcs.py
index e2838f8d..2fef99d6 100644
--- a/ranger/ext/vcs/vcs.py
+++ b/ranger/ext/vcs/vcs.py
@@ -256,9 +256,11 @@ class VcsRoot(Vcs):  # pylint: disable=abstract-method
         self.updatetime = time.time()
         return True
 
-    def _update_walk(self, path, purge):  # pylint: disable=too-many-branches
+    def _update_walk(self, path, purge, isInterrupt=None):  # pylint: disable=too-many-branches
         """Update walk"""
         for wroot, wdirs, _ in os.walk(path):
+            if(isInterrupt and isInterrupt()):
+                return
             # Only update loaded directories
             try:
                 wrootobj = self.obj.fm.directories[wroot]
@@ -272,6 +274,8 @@ class VcsRoot(Vcs):  # pylint: disable=abstract-method
             if wrootobj.content_loaded:
                 has_vcschild = False
                 for fsobj in wrootobj.files_all:
+                    if(isInterrupt and isInterrupt()):
+                        return
                     if purge:
                         if fsobj.is_directory:
                             fsobj.vcsstatus = None
@@ -298,6 +302,8 @@ class VcsRoot(Vcs):  # pylint: disable=abstract-method
 
             # Remove dead directories
             for wdir in list(wdirs):
+                if(isInterrupt and isInterrupt()):
+                    return
                 try:
                     wdirobj = self.obj.fm.directories[os.path.join(wroot, wdir)]
                 except KeyError:
@@ -306,11 +312,13 @@ class VcsRoot(Vcs):  # pylint: disable=abstract-method
                 if not wdirobj.vcs.track or wdirobj.vcs.is_root_pointer:
                     wdirs.remove(wdir)
 
-    def update_tree(self, purge=False):
+    def update_tree(self, purge=False, isInterrupt=None):
         """Update tree state"""
-        self._update_walk(self.path, purge)
+        self._update_walk(self.path, purge, isInterrupt=isInterrupt)
         for path in list(self.links):
-            self._update_walk(path, purge)
+            if(isInterrupt and isInterrupt()):
+                return
+            self._update_walk(path, purge, isInterrupt=isInterrupt)
             try:
                 dirobj = self.obj.fm.directories[path]
             except KeyError:
@@ -325,12 +333,14 @@ class VcsRoot(Vcs):  # pylint: disable=abstract-method
         if purge:
             self.__init__(self.obj)
 
-    def check_outdated(self):
+    def check_outdated(self, isInterrupt=None):
         """Check if root is outdated"""
         if self.updatetime is None:
             return True
 
         for wroot, wdirs, _ in os.walk(self.path):
+            if(isInterrupt and isInterrupt()):
+                return
             wrootobj = self.obj.fm.get_directory(wroot)
             wrootobj.load_if_outdated()
             if wroot != self.path and wrootobj.vcs.is_root_pointer:
@@ -403,6 +413,8 @@ class VcsThread(threading.Thread):  # pylint: disable=too-many-instance-attribut
 
         has_vcschild = False
         for fsobj in fsobjs:
+            if(self.isInterrupt()):
+                return
             if not fsobj.is_directory or not fsobj.vcs or not fsobj.vcs.track:
                 continue
 
@@ -412,7 +424,7 @@ class VcsThread(threading.Thread):  # pylint: disable=too-many-instance-attribut
                 if not rootvcs.rootinit and not self._is_targeted(rootvcs.obj):
                     self._roots.add(rootvcs.path)
                     if not rootvcs.init_root():
-                        rootvcs.update_tree(purge=True)
+                        rootvcs.update_tree(purge=True, isInterrupt=self.isInterrupt)
                     self._redraw = True
                 if fsobj.is_link:
                     fsobj.vcsstatus = rootvcs.obj.vcsstatus
@@ -434,6 +446,8 @@ class VcsThread(threading.Thread):  # pylint: disable=too-many-instance-attribut
                 break
 
         for dirobj in dirobjs:
+            if(self.isInterrupt()):
+                return
             if dirobj.path in paths:
                 continue
             paths.add(dirobj.path)
@@ -441,14 +455,16 @@ class VcsThread(threading.Thread):  # pylint: disable=too-many-instance-attribut
             dirobj.vcs.reinit()
             if dirobj.vcs.track:
                 rootvcs = dirobj.vcs.rootvcs
-                if rootvcs.path not in self._roots and rootvcs.check_outdated():
+                if rootvcs.path not in self._roots and rootvcs.check_outdated(isInterrupt=self.isInterrupt):
                     self._roots.add(rootvcs.path)
                     if rootvcs.update_root():
-                        rootvcs.update_tree()
+                        rootvcs.update_tree(isInterrupt=self.isInterrupt)
                     else:
-                        rootvcs.update_tree(purge=True)
+                        rootvcs.update_tree(purge=True, isInterrupt=self.isInterrupt)
                     self._redraw = True
 
+            if(self.isInterrupt()):
+                return
             has_vcschild = self._update_subroots(dirobj.files_all)
 
             if dirobj.has_vcschild != has_vcschild:
@@ -471,23 +487,27 @@ class VcsThread(threading.Thread):  # pylint: disable=too-many-instance-attribut
             try:
                 self._queue_process()
 
+                if(self.isInterrupt()):
+                    continue
                 if self._redraw:
                     self._redraw = False
                     for column in self._ui.browser.columns:
+                        if(self.isInterrupt()):
+                            continue
                         if column.target and column.target.is_directory:
                             column.need_redraw = True
                     self._ui.status.need_redraw = True
                     self._ui.redraw()
             except Exception as ex:  # pylint: disable=broad-except
                 self._ui.fm.notify('VCS Exception: View log for more info', bad=True, exception=ex)
-
+    def isInterrupt(self):
+        return self.__stop.isSet() or (not self._advance.isSet())
     def stop(self):
         """Stop thread synchronously"""
         self.__stop.set()
-        self.paused.wait(5)
         self._advance.set()
         self._awoken.set()
-        self.stopped.wait(1)
+        self.stopped.wait(0.1)
         return self.stopped.isSet()
 
     def pause(self):
